import{_ as r,a as d,b as o,c as l}from"./sparse-primary-indexes-3-45064b4b.js";import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as u,c as m,d as v,a as e,b as i,e as n,f as s}from"./app-f97e5f0f.js";const p={},_=e("p",null,"En este post vamos a ver una de las DBs OLAP que se jacta de permitirnos operar como ninguna otra: Clickhouse. Haremos un paseo por sus virtudes, falencias y sus tecnologia increiblemente veloz.",-1),h=e("h2",{id:"clickhouse",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#clickhouse","aria-hidden":"true"},"#"),i(" Clickhouse")],-1),b=e("p",null,"ClickHouse es un sistema de gestión de bases de datos (DBMS), con una interfaz SQL muy desarrollada, se auto definen como: de alto rendimiento y orientado a columnas para procesamiento analítico en línea (OLAP). Está disponible su version de código abierto, tambien releases de compañias que ofrecen de alguna manera soporte sobre sus versiones, así como también hay disponible ofertas IasS.",-1),E=e("h3",{id:"engine-mergetree",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#engine-mergetree","aria-hidden":"true"},"#"),i(" ENGINE MergeTree")],-1),g=e("li",null,"Puede ser considerado el engine por defecto de Clickhouse.",-1),f={href:"https://www2.cs.sfu.ca/CourseCentral/354/zaiane/material/notes/Chapter11/node5.html",target:"_blank",rel:"noopener noreferrer"},R=s(`<li>Los datos pueden ser particionados (partitions + parts).</li><li>Sentencia de creación:<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr1] [COMMENT ...] [CODEC(codec1)] [TTL expr1] [PRIMARY KEY],
    name2 [type2] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr2] [COMMENT ...] [CODEC(codec2)] [TTL expr2] [PRIMARY KEY],
    ...
    INDEX index_name1 expr1 TYPE type1(...) [GRANULARITY value1],
    INDEX index_name2 expr2 TYPE type2(...) [GRANULARITY value2],
    ...
    PROJECTION projection_name_1 (SELECT &lt;COLUMN LIST EXPR&gt; [GROUP BY] [ORDER BY]),
    PROJECTION projection_name_2 (SELECT &lt;COLUMN LIST EXPR&gt; [GROUP BY] [ORDER BY])
) ENGINE = MergeTree()
ORDER BY expr
[PARTITION BY expr]
[PRIMARY KEY expr]
[SAMPLE BY expr]
[TTL expr
    [DELETE|TO DISK &#39;xxx&#39;|TO VOLUME &#39;xxx&#39; [, ...] ]
    [WHERE conditions]
    [GROUP BY key_expr [SET v1 = aggr_func(v1) [, v2 = aggr_func(v2) ...]] ] ]
[SETTINGS name=value, ...]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>ENGINE — El engine MergeTree() no lleva parámetros.</li><li>ORDER BY — La clave de ordenamiento (sorting key) - Clickhouse usa la sorting key para determinar como se almacena la información en disco, además sirve en engines de la familia MergeTree para funcionalidades específicas de cada tipo, por ejemplo sirve como clave de agregación en AggregatingMergeTree o de deduplicación en CollapsingMergeTree. Se usa como como clave primaria si PRIMARY KEY no es provista)</li><li>PARTITION BY — La clave de particionado. Opcional. Por ejemplo si se desea particionar por mes: toYYYYMM(date_column), donde date_column es del tipo de dato Date. Las particiones son nomencladas de la forma &quot;YYYYMM&quot;.</li><li>PRIMARY KEY — Opcional. Siempre es igual o un prefijo de la sorting key. En muchos casos es innesesario definir el PRIMARY KEY, toma por defecto ORDER BY. Sirve para armar el indice propiamente dicho (primary.idx).</li></ul></li>`,2),x=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"¿Cuando difieren ORDER BY y PRIMARY KEY?"),e("p",null,"Si por ejemplo en algun momento se requiere agregar una columna mas a una clave de agregación, puede ser recomendable solo modificar la ORDER BY (o sorting key) mediante un ALTER TABLE, manteniendo la PRIMARY KEY, y por lo tanto su archivo de indices, sin modificar. Ahorrandonos de esta manera una reindexación completa, ya que la antigua PK será prefijo de la nueva sorting key, situación aceptable para el funcionamiento del motor. Obiamente la estrategia va a depender de la cardinalidad y el uso como filtro que se le quiera dar a la nueva columna.")],-1),k={class:"hint-container tip"},T=e("p",{class:"hint-container-title"},"Sorting key vs Primary key",-1),y={href:"https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9#:~:text=ORDER%20BY%20(event%2C%20user_id%2C%20dt)&text=Sorting%20key%20defines%20order%20in,will%20be%20structured%20for%20queries.",target:"_blank",rel:"noopener noreferrer"},Y=s(`<h4 id="ejemplo" tabindex="-1"><a class="header-anchor" href="#ejemplo" aria-hidden="true">#</a> Ejemplo</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  CREATE TABLE my_base_raw.transactions_raw(
    \`transaction_id\` Int64,
    \`user_id\` Int32,
    \`created_at\` DateTime(3),
    \`type\` String,
    \`amount\` Decimal(10,2),
    \`__ver\` Int64) ENGINE = MergeTree()
  ORDER BY (transaction_id)
  PARTITION BY toYYYYMM(timestamp)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="particiones-e-indices" tabindex="-1"><a class="header-anchor" href="#particiones-e-indices" aria-hidden="true">#</a> Particiones e Indices</h4><ul><li>A su vez podemos listar las diferentes particiones/parts de cada tabla en Clickhouse consultando la tabla de sistema <code>system.parts</code>.</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT
    partition,
    name,
    active
FROM system.parts
WHERE (table = &#39;transactions_raw&#39;) AND (partition = &#39;202310&#39;)

Query id: 6b6aa9ec-fc61-4217-bd47-a3c4fd9400b5

┌─partition─┬─name────────────────────────┬─active─┐
│ 202310    │ 202310_4475842_4490464_1414 │      1 │
│ 202310    │ 202310_4490465_4511646_1317 │      1 │
│ 202310    │ 202310_4511647_4515242_1330 │      1 │
│ 202310    │ 202310_4515243_4515584_174  │      0 │
│ 202310    │ 202310_4515243_4515585_175  │      0 │
│ 202310    │ 202310_4515243_4515593_183  │      0 │
│ 202310    │ 202310_4515243_4515594_184  │      0 │
│ 202310    │ 202310_4515243_4515595_185  │      1 │
│ 202310    │ 202310_4515595_4515595_0    │      0 │
│ 202310    │ 202310_4515596_4515596_0    │      1 │
│ 202310    │ 202310_4515597_4515597_0    │      1 │
│ 202310    │ 202310_4515598_4515598_0    │      1 │
│ 202310    │ 202310_4515599_4515599_0    │      1 │
└───────────┴─────────────────────────────┴────────┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Desglose del nombre de la parte: 202310_4515243_4515595_185:</p><ul><li><code>202310</code> es el nombre de la partición.</li><li><code>4515243</code> es el número mínimo de la PK del bloque de datos.</li><li><code>4515595</code> es el número máximo de la PK del bloque de datos.</li><li><code>185</code> es la versión de mutación (si una parte ha mutado).</li></ul>`,7),I={href:"https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9#:~:text=ORDER%20BY%20(event%2C%20user_id%2C%20dt)&text=Sorting%20key%20defines%20order%20in,will%20be%20structured%20for%20queries.",target:"_blank",rel:"noopener noreferrer"},L=s('<h4 id="¿como-funcionan-los-indices-esparcidos" tabindex="-1"><a class="header-anchor" href="#¿como-funcionan-los-indices-esparcidos" aria-hidden="true">#</a> ¿Como funcionan los indices esparcidos?</h4><p>Dado el siguiente indice dentro de una partición de una tabla: <img src="'+r+'" alt="primarykeys.jpeg" loading="lazy"> Si en una query utilizamos los siguientes filtros en la dondición WHERE, la poda o pruning inicial sería:</p><ul><li>CounterID in (&#39;a&#39;, &#39;h&#39;) → ranges of marks [0, 3) and [6, 8).</li><li>CounterID IN (&#39;a&#39;, &#39;h&#39;) AND Date = 3 → ranges of marks [2, 3) and [7, 8).</li><li>Date = 3 → range of marks [1, 10].</li></ul><h4 id="representacion-grafica-del-indice-primario-y-estrategia-de-almacenamiento" tabindex="-1"><a class="header-anchor" href="#representacion-grafica-del-indice-primario-y-estrategia-de-almacenamiento" aria-hidden="true">#</a> Representación gráfica del indice primario y estrategia de almacenamiento</h4><img src="'+d+'" style="background-color:white;"><img src="'+o+'" style="background-color:white;"><img src="'+l+'" style="background-color:white;"><h3 id="engine-kafka" tabindex="-1"><a class="header-anchor" href="#engine-kafka" aria-hidden="true">#</a> ENGINE Kafka</h3><p>Las tablas definidas con <code>ENGINE = Kafka</code> hacen las veces de consumidores de eventos en topics, y las cuales no sirven de almacenamiento permanente.</p><h3 id="materializedviews" tabindex="-1"><a class="header-anchor" href="#materializedviews" aria-hidden="true">#</a> MaterializedViews</h3>',10),A={href:"https://den-crane.github.io/Everything_you_should_know_about_materialized_views_commented.pdf",target:"_blank",rel:"noopener noreferrer"},O=e("h3",{id:"wip",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#wip","aria-hidden":"true"},"#"),i(" [WIP]")],-1);function N(C,M){const a=c("ExternalLinkIcon");return u(),m("div",null,[_,v(" more "),h,b,E,e("ol",null,[g,e("li",null,[i("Ordena los datos por indice primario ("),e("a",f,[i("sparse index"),n(a)]),i(").")]),R]),x,e("div",k,[T,e("p",null,[i("Sorting key defines order in which data will be stored on disk, while primary key defines how data will be structured for queries. Usually those are the same (and in this case you can omit PRIMARY KEY expression, Clickhouse will take that info from ORDER BY expression). "),e("a",y,[i("link"),n(a)])])]),Y,e("p",null,[e("a",I,[i("Lectura "),n(a)])]),L,e("p",null,[i('En Clickhouse las vistas materializadas (MaterializedViews) funcionan como "triggers" de la tabla fuente de la consulta, es decir la db ofrece una funcionalidad reactiva ante nuevas filas. '),e("a",A,[i("Lectura"),n(a)])]),O])}const S=t(p,[["render",N],["__file","clickhouse.html.vue"]]);export{S as default};
