import{_ as s,a as r}from"./column-oriented-7b3a134c.js";import{_ as o,a as l,b as d,c}from"./sparse-primary-indexes-3-45064b4b.js";import{_ as h}from"./plugin-vue_export-helper-c27b6911.js";import{r as u,o as m,c as p,d as v,a as e,b as i,e as n,f as t}from"./app-f02742c9.js";const f={},g=e("p",null,"Reporting engines stand as indispensable components in the landscape of information systems. They empower users with access to data, facilitating rapid analysis and informed decision-making.",-1),b=e("p",null,"In this post, we delve into the technical intricacies of syncing a MySQL database with ClickHouse, a columnar oriented engine. This strategic approach lays the foundation for building a robust, scalable, and high-performance analytical engine proficient at handling substantial data volumes.",-1),_=t('<h2 id="big-data-that-s-it-right" tabindex="-1"><a class="header-anchor" href="#big-data-that-s-it-right" aria-hidden="true">#</a> &quot;Big Data, that&#39;s it! Right?&quot;</h2><p>Every day, we witness the exponential growth of information stored, trafficked, and processed. Let&#39;s delve into the complexity by considering the formidable task of gauging the efficacy of a new feature on the frontend of one of the most widely utilized audiovisual playback platforms.</p><p>For the sake of illustration, let&#39;s assume we have a user base of 1 million individuals per day. We introduce the new functionality to a certain percentage (X) of these users, who, on average, interact with it at least four times during their daily sessions. If our A/B test employs a 50/50 distribution, half of the users will exhibit no activity logs, while the other half will generate a minimum of four logs per day. This translates to a staggering 60 million logs per month. After a three-month experimental period rise a colossal 180 million rows that we aim to analyze to validate the effectiveness of our feature.</p><p>The choice of a database engine becomes crucial, varying depending on the software solution offered. While it may seem unconventional to log user interactions into a transactional database, let&#39;s consider an illustrative example within the context of a real-life pipeline. Imagine our project utilizes a MySQL Server, logging each interaction. As previously mentioned, in the worst-case scenario, we analyze the feature&#39;s performance quarterly, dealing with approximately 180 million rows. If our queries contend for resources, irrespective of our hardware&#39;s capacity, it becomes apparent that querying such vast information within a traditional RDBMS could pose challenges.</p><p>In this post, we will explore how to create a synchronization pipeline between our MySQL source database and our ClickHouse analytics database. Additionally, we will use Kafka as the means of synchronization.</p><h2 id="column-oriented-vs-row-oriented" tabindex="-1"><a class="header-anchor" href="#column-oriented-vs-row-oriented" aria-hidden="true">#</a> Column-Oriented vs Row-Oriented</h2><ul><li>In a row-oriented database management system (DBMS), data is stored in rows, with all values related to a row stored physically next to each other. <img src="'+s+'" alt="row-oriented.gif" loading="lazy"></li><li>In a column-oriented DBMS, data is stored in columns, with values from the same columns stored together. <img src="'+r+'" alt="column-oriented.gif" loading="lazy"></li></ul><h2 id="clickhouse" tabindex="-1"><a class="header-anchor" href="#clickhouse" aria-hidden="true">#</a> Clickhouse</h2><p>ClickHouse is a high-performance, column-oriented SQL database management system (DBMS) for online analytical processing (OLAP). It is available as both an open-source software and a cloud offering.</p><h2 id="engine-mergetree" tabindex="-1"><a class="header-anchor" href="#engine-mergetree" aria-hidden="true">#</a> ENGINE MergeTree</h2>',10),y=e("li",null,"It can be considered ClickHouse's default engine.",-1),w={href:"https://www2.cs.sfu.ca/CourseCentral/354/zaiane/material/notes/Chapter11/node5.html",target:"_blank",rel:"noopener noreferrer"},E=t(`<li>Data can be partitioned (partitions + parts).</li><li>Creation statement:<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr1] [COMMENT ...] [CODEC(codec1)] [TTL expr1] [PRIMARY KEY],
    name2 [type2] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr2] [COMMENT ...] [CODEC(codec2)] [TTL expr2] [PRIMARY KEY],
    ...
    INDEX index_name1 expr1 TYPE type1(...) [GRANULARITY value1],
    INDEX index_name2 expr2 TYPE type2(...) [GRANULARITY value2],
    ...
    PROJECTION projection_name_1 (SELECT &lt;COLUMN LIST EXPR&gt; [GROUP BY] [ORDER BY]),
    PROJECTION projection_name_2 (SELECT &lt;COLUMN LIST EXPR&gt; [GROUP BY] [ORDER BY])
) ENGINE = MergeTree()
ORDER BY expr
[PARTITION BY expr]
[PRIMARY KEY expr]
[SAMPLE BY expr]
[TTL expr
    [DELETE|TO DISK &#39;xxx&#39;|TO VOLUME &#39;xxx&#39; [, ...] ]
    [WHERE conditions]
    [GROUP BY key_expr [SET v1 = aggr_func(v1) [, v2 = aggr_func(v2) ...]] ] ]
[SETTINGS name=value, ...]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>ENGINE — The MergeTree() engine takes no parameters.</li><li>ORDER BY — The sorting key - ClickHouse uses the sorting key to determine how information is stored on disk. It also serves specific functions in MergeTree family engines, such as aggregation key in AggregatingMergeTree or deduplication key in CollapsingMergeTree. It is used as the primary key if PRIMARY KEY is not provided.</li><li>PARTITION BY — The partitioning key. Optional. For example, if partitioning by month is desired: toYYYYMM(date_column), where date_column is of the Date data type. Partitions are named in the &quot;YYYYMM&quot; format.</li><li>PRIMARY KEY — Optional. Always the same or a prefix of the sorting key. In many cases, it is unnecessary to define the PRIMARY KEY; it defaults to ORDER BY. It is used to build the index itself (primary.idx).</li></ul></li>`,2),x=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"When do ORDER BY and PRIMARY KEY differ?"),e("p",null,"If, for instance, there is a need to add an additional column to an aggregation key, it might be recommended to only modify the ORDER BY (or sorting key) through an ALTER TABLE, keeping the PRIMARY KEY and, consequently, its index file, unchanged. This way, a complete reindexing can be avoided, as the old PK will be a prefix of the new sorting key, an acceptable situation for the engine's operation. Obviously, the strategy will depend on the cardinality and the intended use as a filter for the new column.")],-1),k={class:"hint-container tip"},R=e("p",{class:"hint-container-title"},"Sorting key vs Primary key",-1),I={href:"https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9#:~:text=ORDER%20BY%20(event%2C%20user_id%2C%20dt)&text=Sorting%20key%20defines%20order%20in,will%20be%20structured%20for%20queries.",target:"_blank",rel:"noopener noreferrer"},T=t(`<h2 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  CREATE TABLE my_base_raw.transactions_raw(
    \`id_transaction\` Int64,
    \`user_id\` Int32,
    \`timestamp\` DateTime(3),
    \`type\` String,
    \`sequence\` string,
    \`amount\` Decimal(10,2),
    \`__ver\` Int64) ENGINE = MergeTree()
  ORDER BY (id_transaction)
  PARTITION BY toYYYYMM(timestamp)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="partitions-and-indexes" tabindex="-1"><a class="header-anchor" href="#partitions-and-indexes" aria-hidden="true">#</a> Partitions and Indexes</h2><ul><li>Additionally, we can list the different partitions/parts of each table in ClickHouse by querying the system.parts system table. <code>system.parts</code>.</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT
    partition,
    name,
    active
FROM system.parts
WHERE (table = &#39;transactions_raw&#39;) AND (partition = &#39;202310&#39;)

Query id: 6b6aa9ec-fc61-4217-bd47-a3c4fd9400b5

┌─partition─┬─name────────────────────────┬─active─┐
│ 202310    │ 202310_4475842_4490464_1414 │      1 │
│ 202310    │ 202310_4490465_4511646_1317 │      1 │
│ 202310    │ 202310_4511647_4515242_1330 │      1 │
│ 202310    │ 202310_4515243_4515584_174  │      0 │
│ 202310    │ 202310_4515243_4515585_175  │      0 │
│ 202310    │ 202310_4515243_4515593_183  │      0 │
│ 202310    │ 202310_4515243_4515594_184  │      0 │
│ 202310    │ 202310_4515243_4515595_185  │      1 │
│ 202310    │ 202310_4515595_4515595_0    │      0 │
│ 202310    │ 202310_4515596_4515596_0    │      1 │
│ 202310    │ 202310_4515597_4515597_0    │      1 │
│ 202310    │ 202310_4515598_4515598_0    │      1 │
│ 202310    │ 202310_4515599_4515599_0    │      1 │
└───────────┴─────────────────────────────┴────────┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Breakdown of the part name: 202310_4515243_4515595_185:</p><ul><li><code>202310</code> is the partition name.</li><li><code>4515243</code> is the minimum PK number of the data block.</li><li><code>4515595</code> is the maximum PK number of the data block.</li><li><code>185</code> is the mutation version (if a part has mutated).rte ha mutado).</li></ul>`,7),Y={href:"https://medium.com/datadenys/how-clickhouse-primary-key-works-and-how-to-choose-it-4aaf3bf4a8b9#:~:text=ORDER%20BY%20(event%2C%20user_id%2C%20dt)&text=Sorting%20key%20defines%20order%20in,will%20be%20structured%20for%20queries.",target:"_blank",rel:"noopener noreferrer"},A=t('<h2 id="how-do-sparse-indices-work" tabindex="-1"><a class="header-anchor" href="#how-do-sparse-indices-work" aria-hidden="true">#</a> How do sparse indices work?</h2><p>Given the following index within a partition of a table: <img src="'+o+'" alt="primarykeys.jpeg" loading="lazy"> If we use the following filters in the WHERE clause of a query, the initial pruning would be:</p><ul><li>CounterID in (&#39;a&#39;, &#39;h&#39;) → ranges of marks [0, 3) and [6, 8).</li><li>CounterID IN (&#39;a&#39;, &#39;h&#39;) AND Date = 3 → ranges of marks [2, 3) and [7, 8).</li><li>Date = 3 → range of marks [1, 10].</li></ul><h2 id="graphical-representation-of-index-and-storage-strategy" tabindex="-1"><a class="header-anchor" href="#graphical-representation-of-index-and-storage-strategy" aria-hidden="true">#</a> Graphical representation of index and storage strategy</h2><img src="'+l+'" style="background-color:white;"><img src="'+d+'" style="background-color:white;"><img src="'+c+'" style="background-color:white;"><h2 id="engine-kafka" tabindex="-1"><a class="header-anchor" href="#engine-kafka" aria-hidden="true">#</a> ENGINE Kafka</h2><p>Tables defined with ENGINE = Kafka act as event consumers in topics and do not serve as permanent storage.</p><h2 id="materializedviews" tabindex="-1"><a class="header-anchor" href="#materializedviews" aria-hidden="true">#</a> MaterializedViews</h2>',10),M={href:"https://den-crane.github.io/Everything_you_should_know_about_materialized_views_commented.pdf",target:"_blank",rel:"noopener noreferrer"},O=e("h3",{id:"wip",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#wip","aria-hidden":"true"},"#"),i(" [WIP]")],-1);function L(N,C){const a=u("ExternalLinkIcon");return m(),p("div",null,[g,b,v(" more "),_,e("ol",null,[y,e("li",null,[i("Organizes data by the primary key ("),e("a",w,[i("sparse index"),n(a)]),i(").")]),E]),x,e("div",k,[R,e("p",null,[i("Sorting key defines order in which data will be stored on disk, while primary key defines how data will be structured for queries. Usually those are the same (and in this case you can omit PRIMARY KEY expression, Clickhouse will take that info from ORDER BY expression). "),e("a",I,[i("link"),n(a)])])]),T,e("p",null,[e("a",Y,[i("Reading"),n(a)])]),A,e("p",null,[i("In ClickHouse, MaterializedViews function as triggers for the source table of the query, meaning the database offers reactive functionality to new rows "),e("a",M,[i("Reading"),n(a)])]),O])}const z=h(f,[["render",L],["__file","clickhouse.html.vue"]]);export{z as default};
